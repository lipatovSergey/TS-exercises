Главная особенность этой проверки проявляется при передаче аргументов в функцию.
Для примера возьмём функцию и тип
```ts
type Point2D = { x: number; y: number;}; 
function printPoint(point: Point2D)
 { 
	 console.log(`X: ${point.x}, Y: ${point.y}`); 
 }
```

Как фидно функция ожидает два аргумена x, y  с типами number.
Если попытаться на прямую передать литеральный объект с избыточным свойством получим ошибку. Ведь функция ожидает только два аргумента, а получает 3.

```ts
printPoint({ x: 3, y: 2, z: 6 })
// Object literal may only specify known properties, and 'z' does not exist in type 'Point2d'
```

НО! При этом если передать переменную хранящую объект с излишним свойстивом, то ошибки не будет. TS в этой ситуации более гибкий и предполагает, что возможно мы хотим использовать избыточное свойство где-то дальше в коде. Но лучше на такое не полагаться.
```ts
const point3d = { x: 3, y: 2, z: 6 }
printPoint(point3d)
```